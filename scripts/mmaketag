#!/bin/bash -eu
#############


# This script currently:
# - version bumps in sfvmk.sc
# - tags esxi_sfc
# - commit and push changes
# - builds sfvmk driver
# - cp vib file -- ??

p=$(basename "$0")
args="$@"

err  () { echo "$*" 1>&2; }
msg () { echo 1>&2 "$p: $*"; }
vmsg () { if ${verbose}; then echo "$p: $*"; fi; }
log  () { err "$p: $*"; }
fail () { log "$@"; exit 1; }

products="esxi_sfc"

usage () {
    err "Usage: mmaketag <branch> [<desired new tag>]"
    err
    err "  branch:"
    err
    err "    The branch can be either 'default' 'sfvmk_dev_x'. If crossing branches,"
    err "    mmaketag will take care to re-exec mmaketag on the target branch."
    err
    err "  desired new tag:"
    err
    err "    The tag can be in the form of the following:"
    err "      v1_1_m"
    err "      v1_1_m_bbbb"
    err "    Note that mmaketag will check that this tag does not already exist"
    err
    exit 1
}

# presanity() tests executed here so that old bash doesn't barf
[ "${EUID}" != "0" ] || fail "Please do not run as root!"
[ "`hostname -s`" = "chisel" ] || fail "Please run on rpm-test1 for consistency"

###############################################################################
# Mercurial operations

hgpull () {
    local repo="$1" lines

    cd ${INCOMING}/${repo}
    hg --noninteractive pull

    if [ ${repo} = esxi_sfc ]; then
        # Check that mmaketag won't change when we update:
        # - Bash will get it's knickers in a right twist if the script
        #   changes underneath it.
        # - Presumably the user should run the new version of mmaketag,
        #   otherwise, why was it changed?
        lines=$(hg diff -r ${newbrancha[${repo}]} ${this} | wc -l)
        if [ "${lines}" != 0 ]; then
            log "! ${this} will be modified when moving to esxi_sfc branch ${newbrancha[${repo}]}"
            log "! execing to the new ${this}"
            # exec to perform the update then run
            exec sh -c "cd $(pwd); $(which hg) --noninteractive update --clean ${newbrancha[${repo}]}; ${this} ${args}"
        fi
    fi

    # We assume that newbranch already exists
    # This will leave esxi_sfc/build
    log "Updating '${repo}' to branch '${newbrancha[${repo}]}'"
    hg --noninteractive update --clean ${newbrancha[${repo}]}
}

hgheadrev () {
    local repo="$1" branch rev

    hg --noninteractive branches | while read branch rev; do
        if [ "${branch}" = "${newbrancha[${repo}]}" ]; then
            echo ${rev}
            break
        fi
    done
}

hgpush () {
    local repo="$1" rev
    echo " ..hg push .."
    echo ${repo}
    msg "push back ${repo} changes"

    cd ${INCOMING}/${repo}
    rev=$(hgheadrev ${repo})
    if [ -z "${rev}" ]; then
        fail "Unable to find tip revision of ${repo} repo branch ${newbrancha[${repo}]}"
    fi
    hg --noninteractive pull
    if [ "$(hgheadrev ${repo})" != "${rev}" ]; then
        log "Repo ${repo} has changed. Merging"
        hg --noninteractive merge ${newbrancha[${repo}]}
        hg --noninteractive commit --message "Task 71858: merge"
    fi
    # Some versions of hg exit with an non-zero error code if their is
    # nothing to push
    hg --noninteractive push || true
}

hglasttag() {
    local repo="$1"
    if [ -n "${lasttag_override}" ]; then
	echo "${lasttag_override}"
        return
    fi

    # The commit to introduce the tag might not be in the next ordinal
    # revision (because a subsequent tag might make a new head). The
    # caller will have to ignore .hgtags differences
    hg --noninteractive log --branch ${newbrancha[${repo}]} --rev "sort(tag(), '-date')" -l 1 --template "{tags}\n" 2>/dev/null
}


###############################################################################
# Repository operations

commitversion () {
    local repo="$1"

    cd ${INCOMING}/${repo}
    vmsg "repo ${repo} commit version ${version}"
    if checkworkingdir ${repo}; then
        hg --noninteractive addremove
        hg --noninteractive commit --message "Task 71858: [${tagfor}] update version numbers to ${version}"
    fi

    echo "commit done ..tagging next"

    # Allow operation=commit to be rerun by making hg tag
    # fail gracefully when it's a no-op, like hg commit already does
    vmsg "repo ${repo} tag ${tag}"
    if [ -z "$(hg --noninteractive tags | grep ${tag})" ]; then
        hg --noninteractive tag ${tag}
    fi
}       

# Return true (via $?) if the repository has changed since the given tag
checktag () {
    local repo tag lines
    repo="$1"

    ${nodiffcheck} && return

    cd ${INCOMING}/${repo}
    tag="$(hglasttag ${repo})"
    # If there's no tag, then the repository needs tagging
    [ -z "${tag}" ] && return

    # Exclude the .htags file (since we can't reliably find the revision that includes it)
    # Exclude imports.mk as it changes each time tags are made
    lines="$(hg --noninteractive diff --rev ${tag} --exclude .hgtags --exclude imports.mk | wc -l)"
    test ${lines} -gt 0
}

# Return true (via $?) if the working directory contains local changes
checkworkingdir () {
    local repo lines
    repo="$1"
    cd ${INCOMING}/${repo}
    lines="$(hg --noninteractive status | wc -l)"
    test ${lines} -gt 0
}

# Update the version number encoded in the .inx files
infupdate () {
    local file

    cd ${INCOMING}/esxi_sfc
    find src/driver/win/ -name \*.inx | while read file; do
        sed -i -e 's/HKR,, Product_Version, 0, "[0-9].[0-9]\+.[0-9]\+"/HKR,, Product_Version, 0, "'${version_major}'.'${version_minor}'.'${version_patch}'"/g' ${file}
    done
}

# Update the files ($2..) in the repository $1 to ${tag}
versionupdate () {
    local repo
    repo="$1"
    shift

    vmsg "updating ${repo} repo to ${tag}"
    echo $version
    local pstamp
    pstamp="${version}_$(date +'%y%m%d-%H%M')"
    echo $pstamp

    # bug 28141/29333 - avoid replacing version numbers within changelogs
    local predicate
    if [ "${repo}" = "distfiles" ]; then
	predicate="1,+7"
    else
	predicate=""
    fi

    for file in $*; do
        cd ${INCOMING}/${repo}
	# bug 32894: Only replace version numbers starting with v|"|=|whitespace
        sed -i \
            -e ${predicate}' s/\([v"=[:space:]]\)[0-9]\.[0-9]\+\.[0-9]\+\.[0-9]\{4\}/\1'${version}'/g'                      \
            -e ${predicate}' s/\([v"=[:space:]]\)[0-9]\.[0-9]\+\.[0-9]\+/\1'${version_major}'.'${version_minor}'.'${version_patch}'/g' \
            -e ${predicate}' s/[(][0-9]\{4\}[)]/('${version_build}')/g'                                                       \
            -e ${predicate}' s/\(CI_MAJ_RELEASE_VERSION[ ]\+\)[(][0-9]\+[)]/\1('${version_major}')/'                          \
            -e ${predicate}' s/\(CI_MIN_RELEASE_VERSION.*\)[(][0-9]\+[)]/\1('${version_minor}')/'                             \
            -e ${predicate}' s/\(CI_MAINT_RELEASE_VERSION.*\)[(][0-9]\+[)]/\1('${version_patch}')/'                        \
            -e ${predicate}' s/\(<SfVersionMajor>\)[0-9]\+/\1'${version_major}'/'                                             \
            -e ${predicate}' s/\(<SfVersionMinor>\)[0-9]\+/\1'${version_minor}'/'                                             \
            -e ${predicate}' s/\(<SfVersionPatch>\)[0-9]\+/\1'${version_patch}'/'                                       \
            -e ${predicate}' s/\(<SfVersionBuild>\)[0-9]\+/\1'${version_build}'/'                                             \
            ${file}

        if [ "${file}" = "src/pkg/sysv/SFCsfxge/pkginfo" ]; then
          sed -i -e 's/^PSTAMP=.*$/PSTAMP="'${pstamp}'"/' ${file}
        fi
    done
}

# tag may be of the form
#  va_b_c_d
#  va_b_c
#  nothing
validatetag () {
    local lasttag lastversion lastversion_major lastversion_minor lastversion_patch lastversion_build
    local _IFS="${IFS}"
    local repo="esxi_sfc" # TODO This should check all branches

    # Check that we're running on thisbranch
    [ "${newbrancha[${repo}]}" = "${thisbranch}" ] || \
        fail "Running on the wrong v5 branch. want=${newbrancha[${repo}]} this=${thisbranch}. "\
             "Did you skip --operation=pull?"

    # Find the latest tag on the branch
    #cd ${INCOMING}/esxi_sfc
    #lasttag="$(hglasttag esxi_sfc)"
    #IFS=_; eval set -- ${lasttag}; IFS="${_IFS}"
    #[ $# = 4 ] && [[ "${lasttag}" =~ v4_[0-9]+_[0-9]+_[0-9]{4} ]] || \
    #    fail "Current branch '${newbrancha[${repo}]}' head tag '${lasttag}' is invalid. "\
    #         "Try using --lasttag to point at the last normal tag"
    # If you hit this because there is a bad tag in history then you will need
    # to run a modified version of this script with hardcoded lasttag

    #lastversion_major="${1:1}"
    #lastversion_minor="$2"
    #lastversion_patch="$3"
    #lastversion_build="$4"
    #lastversion="${lastversion_major}.${lastversion_minor}.${lastversion_patch}.${lastversion_build}"

    #if [ -z "${tag}" ]; then
     #   tag="v${lastversion_major}_${lastversion_minor}_${lastversion_patch}_$((lastversion_build + 1))"
    # Note need to match in longest prefix order
    #elif [[ ${tag} =~ v4_[0-9]+_[0-9]+_[0-9]{4} ]]; then
#	tag="${tag}"
 #   elif [[ ${tag} =~ v4_[0-9]+_[0-9]+ ]]; then
 #       tag="${tag}_$((lastversion_build + 1))"
 #   else
 #       fail "Tag '${tag}' has an invalid format. Should be v4_M_m[_bbbb]"
 #   fi

  #  msg "Will move branch '${newbrancha[${repo}]}' from '${lasttag}' to '${tag}'"

    # Check if this tag exists on any branch
    cd ${INCOMING}/v5
    if hg --noninteractive log --rev "${tag}" >/dev/null 2>&1; then
        fail "New tag '${tag}' already exists in repository"
    fi

    # Validate the major, minor and build numbers of tag
    IFS=_; eval set -- ${tag}; IFS="${_IFS}"
    version_major="${1:1}"
    version_minor="$2"
    version_patch="$3"
    version_build="$4"
    version="${version_major}.${version_minor}.${version_patch}.${version_build}"
    # mmaketag defanged to allow mmaketag'ing on a branch
}

# Return true if the current operation matches $1
# $2 should be "silent" for anything outside of maketag() to avoid
#   progress messaging
runop () {
    if [ "${operation}" = "all" -o "${operation}" = "$1" ]; then
        [ $# -lt 2 ] && msg ">>> operation=$1:"
        return 0
    fi
    return 1
}

checkdeps () {
    for repo in $check_trees; do
        # Check that the repos exist
        [ -d "${INCOMING}/${repo}" ] || fail "'${INCOMING}/${repo}' does not exist. " \
	    "Try 'hg --noninteractive --cwd ${INCOMING} clone /project/hg/incoming/${repo}'"

        cd "${INCOMING}/${repo}"

	egrep '^default\s*=\s*http' .hg/hgrc > /dev/null && \
            fail "Repo '${repo}' checked out from http (so read-only)" || true
    done
}

tinderboxcheck() {
    if $prompt && runop commit silent; then
	# Manual check for now
	echo
	echo "*** Please consult http://tinderbox/ to check that the current tree builds (to avoid bad tags) ***"
	read -p "Press enter to proceed (or use --noprompt) ..."
	echo "Thanks, proceeding ..."
    fi
}

checkowner() {
    local file=$1
    if [ -e "${file}" ]; then
	[ -O "${file}" ] || fail "'${file}' is owned by another user"
    fi    
}

sanitychecks () {
    checkowner "${INCOMING}/esxi_sfc/"
    checkowner "$USERBUILD"

    if runop pull silent; then
	for repo in $check_trees; do
            cd "${INCOMING}/${repo}"

            # Check no local changes
            #if ! $clean; then
#		lines=$(hg --noninteractive status | wc -l)
#		[ "${lines}" = 0 ] || fail "Repo ${repo} has local changes. Aborting"
 #           fi

	    # Check no outgoing commits
	    cd "${INCOMING}/${repo}"
	   # hg --noninteractive outgoing | egrep '^no changes found' > /dev/null || \
	#	fail "Repo ${repo} has outgoing changes"

           # Check no applied mqueue patches - without needing mqueue extension
            hg --noninteractive tags | grep qparent && \
		fail "Repo ${repo} has mqueue patches applied. Aborting" || true
	done
    fi
}

_checktagexists() {
    local repopath=$1
    local reponame=$2
    local tag=$3
    hg --noninteractive -R "${repopath}/${reponame}" log -r "$tag" >/dev/null 2>&1
}

checktagexists() {
    _checktagexists "${INCOMING}" $*
}

checkcentraltagexists() {
    _checktagexists "${HGCENTRAL}" $*
}

checklasttag() {
     if [ -n "${lasttag_override}" ]; then
	 checktagexists esxi_sfc "${lasttag_override}" || \
	     fail "--lasttag=${lasttag_override} does not exist"
     fi
}

checkrequiredargs() {
    [ "${branch}" == "${branch/\-\-/X}" ] || \
	fail "Please check -- arguments are first"
    [ "${tag}" == "${tag/\-\-/X}" ] || \
	fail "Please check -- arguments are first"
}


hgpullall() {
    local repo
    # We must pull before we can canonicalize the tag
    if runop pull; then
        for repo in $check_trees; do
            hgpull ${repo}
        done
    fi
}


copy_tmp_build_products () {
    # The tag is going to be pushed so also copy any files destined for
    # $BUILDPRODUCTS into place at $FINALBUILDPRODUCTS
    local src="${BUILDPRODUCTS}/${tag}"
    local dst="${FINALBUILDPRODUCTS}"
    [ -d "${src}" ] || fail "cp -R src '${src}' is not a directory"
    [ -d "${dst}" ] || fail "cp -R dst '${dst}' is not a directory"
    if ! cp -R "${src}" "${dst}"; then
	err "Failed to 'cp -R ${src} ${dst}'"
	err "Please enter the root password (for chmod'ing ${dst}/${tag}):"
	su -c "su runbench -c 'chmod a+w ${dst}/${tag}'"
	# Retry
	cp -R "${src}" "${dst}" || fail "Failed to 'cp -R ${src} ${dst}'"
    fi
}


maketag () {
    local oldtag repo

    # If the user uses --operation, then this gets run on every invocation
    # Don't run for --operation=PUSH because the new tag is already commited
    #if [[ "${operation}" != push ]]; then
    validatetag
    #fi

    TMPDIR=$(mktemp -dt mmaketag.$USER.XXXXXXXX)
    #trap "echo \"Please cleanup temporary directory ${TMPDIR}\"" EXIT;
    # use readlink to ensure that this starts with a /
    export BUILDPRODUCTS="${TMPDIR}$(readlink -f ${FINALBUILDPRODUCTS})"
    mkdir -p "${BUILDPRODUCTS}"

    changed=false
    for repo in $tag_trees; do
        if checktag ${repo}; then
            changed=true
            break
        fi
    done

    if $changed; then
        if runop version silent; then
            #infupdate
            versionupdate native_drv/sfvmk.sc
        fi
        if runop build; then
                echo "Creating VIB and offline bundle packages."
                #genaoepkg ${tag} $BUILDPRODUCTS
        fi
        if runop commit; then
            for repo in $tag_trees; do
                commitversion ${repo}
            done
        fi
    elif runop version silent || runop build silent; then
        fail "All repos unchanged since last tag! Nothing to do"
    fi

    if runop push; then
	local answer=""
	until [ "$answer" = "y" -o "$answer" = "n" ]; do
	    echo
	    echo "Note that the above firmware versions **do not apply** to this v5 tag"
	    echo "(until a future v5 imports.mk points at this MCFW)"
	    echo
	    echo "You can explore the changes with 'hg outgoing -p'"
	    echo "You can request a test of these changes here http://tinderbox/request"
	    read -p "Do you want to push the above tag ${tag} (y/n)" answer
	done
	if [ "$answer" = "y" ]; then
	    #copy_tmp_build_products
            for repo in $push_trees; do
		hgpush ${repo}
            done

	    changes_pushed=true
	    msg "Changes have been pushed. Tag ${tag} was created."
	else
	    fail "Please hg strip the outgoing commits from your repo"
	fi    
    fi
    rm -Rf ${TMPDIR}
    trap - EXIT
}

###############################################################################
# main()

tagfor=
newbranch=
declare -A newbrancha
tag=
verbose=false
operation=all
nodiffcheck=false
lasttag_override=
clean=false
prompt=true
firmwarefamily_tag=
changes_pushed=false

# Trees that must exist, be clean and will be pulled and udpated
check_trees="esxi_sfc"

# Trees that will be tagged
tag_trees="esxi_sfc"

# Trees that will be pushed (tends to be check_trees in reverse)
push_trees="esxi_sfc"

# When switching branches, mmaketag will exec the mmaketag
# from the destination branch. This variable encodes the
# branch that *this* mmaketag runs on
thisbranch=default

newbrancha["esxi_sfc"]="default"

# effectively v4_11
#                ^ thisminor
thisminor=11  # need to manually make/push a tag if this changes

# The canonical path to this script inside the v5 repository
this="scripts/mmaketag"

# cd to ensure that mmaketool is not available due to . in PATH
#(cd /; which mmaketool) > /dev/null || fail "Please ensure 'v5/scripts' is in your PATH"

# BUILDPRODUCTS is set in mmaketag() to point to a temporary staging area
# This is so that consistency is maintined even if the tag is not pushed.
export FINALBUILDPRODUCTS="/home/vijays/build-products"
#export TOPPATH="$(mmaketool --toppath)"
#export INCOMING="$(mmaketool --toppath)/.."
#export USERBUILD="$(mmaketool --userbuild)"
export TOPPATH="$(pwd)"
export INCOMING="$(pwd)/.."
export USERBUILD="$(pwd)/native_drv/build"
export HGCENTRAL="/project/hg/incoming"

while [ $# -gt 0 ]; do
    case "$1" in
        -v)
            verbose=true
            ;;
        --operation=*)
            operation=${1:12}
            ;;
        --operation)
            operation=$2
            shift
            ;;
       -*)
           usage
           ;;
       *)
           break
           ;;
   esac
   shift
done

case "${operation}" in
    all|pull|version|build|commit|push)
        ;;
    *)
        fail "Unrecognised operation - ${operation}"
        ;;
esac

[ $# = 2 -o $# = 1 ] || usage

branch=$1
echo $branch
tag=${2:-}

# create build products as group writeable.
umask 0002
echo ${INCOMING}
checkrequiredargs
checkdeps
tinderboxcheck
sanitychecks

#hgpullall
checklasttag
# Note checknewtag is in maketag

# Note this promts if to push
# Preceeding functions should not create permanent files/take actions until
# the user agrees
maketag
${changes_pushed} && log "Please update the correct !TEST! entry with details"
